{"version":3,"file":"request-post-events-callback.js","sources":["../index.js"],"sourcesContent":["// @TODO(philipp): The Safari, Edge and Internet Explorer implementation\n// are not bulletproof yet so I do not suggest you rely on this.\n\nlet requestPostEventsCallback, cancelPostEventsCallback;\n\nconst hasNativeSetImmediate =\n  typeof window.setImmediate === \"function\" &&\n  /\\[native code\\]/.test(window.setImmediate.toString());\n\n// TODO(philipp): Find a better way to feature detect Safari and use the\n// postMessage implementation.\nconst isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\nif (hasNativeSetImmediate) {\n  // In case of a native setImmediate function (since this might be\n  // polyfilled incorrectly, we rely on this function). This will be the\n  // case in MS Edge and Internet Explorer.\n\n  requestPostEventsCallback = window.setImmediate.bind(window);\n  cancelPostEventsCallback = window.clearImmediate.bind(window);\n} else if (isSafari) {\n  // In Safari we can use the postMessage workaround as used in a popular\n  // setImmediate polyfill.\n  //\n  // @see https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js\n  // @see https://developer.mozilla.org/en/DOM/window.postMessage\n\n  let queue = [];\n  let nextHandle = 1;\n\n  const messagePrefix = \"rPEC$\" + Math.random();\n  const realm = createRealm();\n\n  const onGlobalMessage = function(event) {\n    if (\n      event.source === window &&\n      event.data === messagePrefix &&\n      queue.length > 0\n    ) {\n      const { fn } = queue.shift();\n      fn();\n    }\n  };\n\n  realm.addEventListener(\"message\", onGlobalMessage);\n\n  requestPostEventsCallback = function(fn) {\n    realm.postMessage(messagePrefix, \"*\");\n    queue.push({ fn, handle: nextHandle });\n    return nextHandle++;\n  };\n\n  cancelPostEventsCallback = function(handle) {\n    queue.splice(queue.findIndex(q => q.handle === handle), 1);\n  };\n} else {\n  // If no one of the above detections work, we fall back to rAF. This\n  // should be the case in Chrome and Firefox, where rAF will be fired\n  // before the next paint.\n\n  requestPostEventsCallback = requestAnimationFrame.bind(window);\n  cancelPostEventsCallback = cancelAnimationFrame.bind(window);\n}\n\nfunction createRealm() {\n  const iframe = document.createElement(\"iframe\");\n  const { documentElement } = document;\n  iframe.style.display = \"none\";\n  iframe.setAttribute(\"aria-hidden\", \"true\");\n  documentElement.appendChild(iframe);\n  return iframe.contentWindow;\n}\n\nexport { requestPostEventsCallback, cancelPostEventsCallback };\n"],"names":["const","iframe","documentElement","hasNativeSetImmediate","window","setImmediate","test","toString","isSafari","navigator","userAgent","requestPostEventsCallback","bind","cancelPostEventsCallback","clearImmediate","let","queue","nextHandle","messagePrefix","Math","random","realm","document","createElement","style","display","setAttribute","appendChild","contentWindow","addEventListener","event","source","data","length","fn","shift","postMessage","push","handle","splice","findIndex","q","requestAnimationFrame","cancelAnimationFrame"],"mappings":"AAKAA,IA4DQC,EACEC,EA7DJC,EAC2B,mBAAxBC,OAAOC,cACd,kBAAkBC,KAAKF,OAAOC,aAAaE,YAIvCC,EAAW,iCAAiCF,KAAKG,UAAUC,WAEjE,GAAIP,EAKFQ,kCAA4BP,OAAOC,aAAaO,KAAKR,QACrDS,iCAA2BT,OAAOU,eAAeF,KAAKR,aACjD,GAAII,EAAU,CAOnBO,IAAIC,KACAC,EAAa,EAEXC,EAAgB,QAAUC,KAAKC,SAC/BC,GAkCApB,EAASqB,SAASC,cAAc,UAC9BrB,2BACRD,EAAOuB,MAAMC,QAAU,OACvBxB,EAAOyB,aAAa,cAAe,QACnCxB,EAAgByB,YAAY1B,GACrBA,EAAO2B,eA1BdP,EAAMQ,iBAAiB,UAXC,SAASC,GAE7BA,EAAMC,SAAW3B,QACjB0B,EAAME,OAASd,GACfF,EAAMiB,OAAS,IAGfC,EADelB,EAAMmB,gBAOzBxB,kCAA4B,SAASuB,GAGnC,OAFAb,EAAMe,YAAYlB,EAAe,KACjCF,EAAMqB,SAAOH,EAAII,OAAQrB,IAClBA,KAGTJ,iCAA2B,SAASyB,GAClCtB,EAAMuB,OAAOvB,EAAMwB,mBAAUC,UAAKA,EAAEH,SAAWA,IAAS,SAO1D3B,kCAA4B+B,sBAAsB9B,KAAKR,QACvDS,iCAA2B8B,qBAAqB/B,KAAKR"}